/**
 * RADS TOOLING - Product Image Drag & Drop
 * Features: Drag images between products, visual feedback, backend sync, custom events
 * 
 * Usage:
 * 1. Include this script: <script src="/assets/JS/product-dragdrop.js"></script>
 * 2. Ensure product cards have data-pid attribute
 * 3. Listen for custom events: 'imageDragStart', 'imageDrop', 'imageMoved'
 * 
 * Backend Endpoint (optional):
 * POST /api/products/{toProductId}/images/move
 * Body: { imageId, fromProductId }
 */

(function() {
  'use strict';

  // Configuration
  const CONFIG = {
    // Backend API endpoint pattern
    // {toProductId} will be replaced with actual product ID
    apiEndpoint: '/RADS-TOOLING/backend/api/product_images.php?action=move&product_id={toProductId}',
    
    // Enable backend sync (set to false for UI-only mode)
    enableBackend: true,
    
    // Toast duration (ms)
    toastDuration: 3000,
    
    // CSS classes
    classes: {
      dragging: 'is-dragging',
      dropTarget: 'drop-target',
      card: 'rt-card',
      imageWrap: 'rt-imgwrap',
      productName: 'rt-name'
    }
  };

  // State
  let draggedImage = null;
  let draggedFromProduct = null;
  let isDragging = false;

  /**
   * Initialize drag & drop system
   */
  function init() {
    console.log('[DragDrop] Initializing product image drag & drop...');
    
    // Make product images draggable
    initDraggableImages();
    
    // Make product cards drop targets
    initDropTargets();
    
    console.log('[DragDrop] Initialization complete');
  }

  /**
   * Make all product images draggable
   */
  function initDraggableImages() {
    const imageWraps = document.querySelectorAll(`.${CONFIG.classes.imageWrap}`);
    
    imageWraps.forEach(imgWrap => {
      // Set draggable attribute
      imgWrap.setAttribute('draggable', 'true');
      
      // Drag start
      imgWrap.addEventListener('dragstart', handleDragStart);
      
      // Drag end
      imgWrap.addEventListener('dragend', handleDragEnd);
    });
    
    console.log(`[DragDrop] Made ${imageWraps.length} images draggable`);
  }

  /**
   * Make all product cards drop targets
   */
  function initDropTargets() {
    const cards = document.querySelectorAll(`.${CONFIG.classes.card}`);
    
    cards.forEach(card => {
      // Drag over
      card.addEventListener('dragover', handleDragOver);
      
      // Drag enter
      card.addEventListener('dragenter', handleDragEnter);
      
      // Drag leave
      card.addEventListener('dragleave', handleDragLeave);
      
      // Drop
      card.addEventListener('drop', handleDrop);
    });
    
    console.log(`[DragDrop] Made ${cards.length} cards drop targets`);
  }

  /**
   * Handle drag start event
   * @param {DragEvent} e
   */
  function handleDragStart(e) {
    const card = this.closest(`.${CONFIG.classes.card}`);
    if (!card) return;

    isDragging = true;
    
    // Get image data
    const img = this.querySelector('img');
    draggedImage = {
      id: this.dataset.imageId || null,
      url: img?.src || '',
      alt: img?.alt || ''
    };
    
    draggedFromProduct = card.dataset.pid;
    
    // Visual feedback
    card.classList.add(CONFIG.classes.dragging);
    
    // Set drag data
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', draggedFromProduct);
    
    // Custom drag image (optional)
    if (img) {
      const dragImg = img.cloneNode();
      dragImg.style.opacity = '0.5';
      e.dataTransfer.setDragImage(dragImg, 50, 50);
    }
    
    // Emit custom event
    document.dispatchEvent(new CustomEvent('imageDragStart', {
      detail: {
        imageId: draggedImage.id,
        imageUrl: draggedImage.url,
        fromProductId: draggedFromProduct
      }
    }));
    
    console.log('[DragDrop] Drag started:', { 
      imageId: draggedImage.id, 
      fromProductId: draggedFromProduct 
    });
  }

  /**
   * Handle drag end event
   * @param {DragEvent} e
   */
  function handleDragEnd(e) {
    isDragging = false;
    
    // Remove visual feedback from all cards
    const cards = document.querySelectorAll(`.${CONFIG.classes.card}`);
    cards.forEach(card => {
      card.classList.remove(CONFIG.classes.dragging);
      card.classList.remove(CONFIG.classes.dropTarget);
    });
    
    console.log('[DragDrop] Drag ended');
  }

  /**
   * Handle drag over event (allow drop)
   * @param {DragEvent} e
   */
  function handleDragOver(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  }

  /**
   * Handle drag enter event (highlight drop target)
   * @param {DragEvent} e
   */
  function handleDragEnter(e) {
    if (!isDragging) return;
    
    const card = this.closest(`.${CONFIG.classes.card}`);
    if (!card) return;
    
    const toProductId = card.dataset.pid;
    
    // Don't highlight source card
    if (toProductId === draggedFromProduct) return;
    
    // Highlight drop target
    card.classList.add(CONFIG.classes.dropTarget);
  }

  /**
   * Handle drag leave event (remove highlight)
   * @param {DragEvent} e
   */
  function handleDragLeave(e) {
    // Check if we're leaving the card (not just a child element)
    const card = this.closest(`.${CONFIG.classes.card}`);
    if (!card) return;
    
    // Only remove highlight if we're leaving the card itself
    const relatedTarget = e.relatedTarget;
    if (relatedTarget && card.contains(relatedTarget)) return;
    
    card.classList.remove(CONFIG.classes.dropTarget);
  }

  /**
   * Handle drop event
   * @param {DragEvent} e
   */
  function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (!isDragging) return;
    
    const card = this.closest(`.${CONFIG.classes.card}`);
    if (!card) return;
    
    const toProductId = card.dataset.pid;
    
    // Remove drop target highlight
    card.classList.remove(CONFIG.classes.dropTarget);
    
    // Don't drop on same product
    if (toProductId === draggedFromProduct) {
      console.log('[DragDrop] Drop cancelled: same product');
      return;
    }
    
    // Emit custom event
    document.dispatchEvent(new CustomEvent('imageDrop', {
      detail: {
        imageId: draggedImage.id,
        imageUrl: draggedImage.url,
        fromProductId: draggedFromProduct,
        toProductId: toProductId
      }
    }));
    
    console.log('[DragDrop] Image dropped:', {
      imageId: draggedImage.id,
      from: draggedFromProduct,
      to: toProductId
    });
    
    // Handle the move (backend sync + UI update)
    handleImageMove(draggedImage, draggedFromProduct, toProductId, card);
  }

  /**
   * Handle image move (backend + UI)
   * @param {Object} image - Image data
   * @param {string} fromProductId - Source product ID
   * @param {string} toProductId - Target product ID
   * @param {HTMLElement} toCard - Target card element
   */
  async function handleImageMove(image, fromProductId, toProductId, toCard) {
    const toProductName = getProductName(toCard);
    
    if (CONFIG.enableBackend) {
      try {
        // Call backend API
        const success = await moveImageBackend(image.id, fromProductId, toProductId);
        
        if (success) {
          // Update UI
          updateProductCardImage(fromProductId, toProductId, image.url);
          
          // Show success toast
          showToast(`Image moved to ${toProductName}`, 'success');
          
          // Emit success event
          document.dispatchEvent(new CustomEvent('imageMoved', {
            detail: {
              imageId: image.id,
              imageUrl: image.url,
              fromProductId,
              toProductId,
              synced: true
            }
          }));
          
          console.log('[DragDrop] Image moved successfully (synced)');
        } else {
          throw new Error('Backend returned failure');
        }
      } catch (error) {
        console.error('[DragDrop] Backend sync failed:', error);
        
        // Fallback: UI-only update
        updateProductCardImage(fromProductId, toProductId, image.url);
        showToast(`Image moved to ${toProductName} (not saved)`, 'warning');
        
        // Emit event with synced: false
        document.dispatchEvent(new CustomEvent('imageMoved', {
          detail: {
            imageId: image.id,
            imageUrl: image.url,
            fromProductId,
            toProductId,
            synced: false,
            error: error.message
          }
        }));
      }
    } else {
      // UI-only mode (no backend)
      updateProductCardImage(fromProductId, toProductId, image.url);
      showToast(`Image moved to ${toProductName} (UI only)`, 'info');
      
      // Emit event
      document.dispatchEvent(new CustomEvent('imageMoved', {
        detail: {
          imageId: image.id,
          imageUrl: image.url,
          fromProductId,
          toProductId,
          synced: false
        }
      }));
      
      console.log('[DragDrop] Image moved (UI only, backend disabled)');
    }
  }

  /**
   * Move image via backend API
   * @param {string|null} imageId - Image ID
   * @param {string} fromProductId - Source product ID
   * @param {string} toProductId - Target product ID
   * @returns {Promise<boolean>}
   */
  async function moveImageBackend(imageId, fromProductId, toProductId) {
    const endpoint = CONFIG.apiEndpoint.replace('{toProductId}', toProductId);
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'same-origin',
      body: JSON.stringify({
        imageId: imageId,
        fromProductId: fromProductId
      })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.message || 'Backend returned failure');
    }
    
    return true;
  }

  /**
   * Update UI: swap images between product cards
   * @param {string} fromPid - Source product ID
   * @param {string} toPid - Target product ID
   * @param {string} imageUrl - Image URL
   */
  function updateProductCardImage(fromPid, toPid, imageUrl) {
    const fromCard = document.querySelector(`.${CONFIG.classes.card}[data-pid="${fromPid}"]`);
    const toCard = document.querySelector(`.${CONFIG.classes.card}[data-pid="${toPid}"]`);
    
    if (!fromCard || !toCard) {
      console.warn('[DragDrop] Could not find cards for image swap');
      return;
    }
    
    const fromImg = fromCard.querySelector(`.${CONFIG.classes.imageWrap} img`);
    const toImg = toCard.querySelector(`.${CONFIG.classes.imageWrap} img`);
    
    if (!fromImg || !toImg) {
      console.warn('[DragDrop] Could not find images for swap');
      return;
    }
    
    // Swap images
    const tempSrc = toImg.src;
    const tempAlt = toImg.alt;
    
    toImg.src = imageUrl;
    toImg.alt = fromImg.alt;
    
    fromImg.src = tempSrc;
    fromImg.alt = tempAlt;
    
    console.log('[DragDrop] UI updated: images swapped');
  }

  /**
   * Get product name from card
   * @param {HTMLElement} card - Product card element
   * @returns {string}
   */
  function getProductName(card) {
    const nameEl = card.querySelector(`.${CONFIG.classes.productName}`);
    return nameEl?.textContent?.trim() || 'Product';
  }

  /**
   * Show toast notification
   * @param {string} message - Toast message
   * @param {string} type - Toast type (success|warning|error|info)
   */
  function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `toast toast--${type}`;
    toast.textContent = message;
    
    // Styling
    const colors = {
      success: '#3db36b',
      warning: '#f59e0b',
      error: '#ef4444',
      info: '#2f5b88'
    };
    
    toast.style.cssText = `
      position: fixed;
      top: 100px;
      right: 20px;
      background: ${colors[type] || colors.info};
      color: #fff;
      padding: 1rem 1.5rem;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 10000;
      font-weight: 600;
      font-family: 'Poppins', sans-serif;
      animation: slideInRight 0.3s ease;
    `;
    
    document.body.appendChild(toast);
    
    // Auto-remove
    setTimeout(() => {
      toast.style.animation = 'slideOutRight 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, CONFIG.toastDuration);
  }

  /**
   * Public API
   */
  window.ProductDragDrop = {
    init: init,
    getConfig: () => ({ ...CONFIG }),
    setConfig: (newConfig) => Object.assign(CONFIG, newConfig),
    showToast: showToast
  };

  // Auto-initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Add CSS animations if not already present
  if (!document.getElementById('dragdrop-animations')) {
    const style = document.createElement('style');
    style.id = 'dragdrop-animations';
    style.textContent = `
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      
      @keyframes slideOutRight {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }

})();

/**
 * USAGE EXAMPLES:
 * 
 * 1. Listen for custom events:
 * 
 * document.addEventListener('imageDragStart', function(e) {
 *   console.log('Drag started:', e.detail);
 *   // { imageId, imageUrl, fromProductId }
 * });
 * 
 * document.addEventListener('imageDrop', function(e) {
 *   console.log('Image dropped:', e.detail);
 *   // { imageId, imageUrl, fromProductId, toProductId }
 * });
 * 
 * document.addEventListener('imageMoved', function(e) {
 *   console.log('Image moved:', e.detail);
 *   // { imageId, imageUrl, fromProductId, toProductId, synced }
 * });
 * 
 * 2. Configure API endpoint:
 * 
 * ProductDragDrop.setConfig({
 *   apiEndpoint: '/api/products/{toProductId}/images/move',
 *   enableBackend: true
 * });
 * 
 * 3. Disable backend (UI-only mode):
 * 
 * ProductDragDrop.setConfig({
 *   enableBackend: false
 * });
 * 
 * 4. Show custom toast:
 * 
 * ProductDragDrop.showToast('Custom message', 'success');
 */